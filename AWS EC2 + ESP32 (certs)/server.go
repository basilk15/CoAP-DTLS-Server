package main

import (
    "bytes"
    "crypto/tls"
    "io"
    "log"

    coap "github.com/plgd-dev/go-coap/v2"
    "github.com/plgd-dev/go-coap/v2/message"
    "github.com/plgd-dev/go-coap/v2/message/codes"
    "github.com/plgd-dev/go-coap/v2/mux"

    "github.com/pion/dtls/v2"
)

func main() {
    r := mux.NewRouter()

    r.Handle("/test", mux.HandlerFunc(func(w mux.ResponseWriter, req *mux.Message) {
        switch req.Code {
        case codes.GET:
            log.Println("GET /test")
            w.SetResponse(codes.Content, message.TextPlain,
                bytes.NewReader([]byte("Hello from Go DTLS v2 server!")))
        case codes.POST:
            body, _ := io.ReadAll(req.Body)
            log.Println("POST /test payload:", string(body))
            w.SetResponse(codes.Changed, message.TextPlain,
                bytes.NewReader([]byte("POST received securely")))
        case codes.PUT:
            body, _ := io.ReadAll(req.Body)
            log.Println("PUT /test payload:", string(body))
            w.SetResponse(codes.Changed, message.TextPlain,
                bytes.NewReader([]byte("PUT received securely")))
        default:
            w.SetResponse(codes.MethodNotAllowed, message.TextPlain,
                bytes.NewReader([]byte("Not allowed")))
        }
    }))

    // Load server certificate and key generated by:
    // openssl req -x509 -newkey rsa:4096 -keyout key.pem -out cert.pem -days 365 -nodes
    cert, err := tls.LoadX509KeyPair("cert.pem", "key.pem")
    if err != nil {
        log.Fatalf("failed to load server certificate: %v", err)
    }

    dtlsCfg := &dtls.Config{
        Certificates: []tls.Certificate{cert},
        ClientAuth:   dtls.NoClientCert, // ESP32 does not send a client certificate
    }

    log.Println("DTLS (cert-based) CoAP v2 server running on port 5684...")

    if err := coap.ListenAndServeDTLS("udp", ":5684", dtlsCfg, r); err != nil {
        log.Fatalf("Server error: %v", err)
    }
}

